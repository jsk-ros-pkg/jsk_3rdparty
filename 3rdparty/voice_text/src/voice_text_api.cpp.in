/*
 * voice_text_server.cpp
 * Mainly copied from voice_text.cpp.include
 * Support new vtapi
 */

#include <fstream>
#include <cstdlib>
#include <sstream>
#include <string>

#include <boost/filesystem.hpp>
#include <boost/thread.hpp>

// ROS
#include <ros/ros.h>
#include <dynamic_reconfigure/server.h>
#include <voice_text/VoiceTextConfig.h>
#include <voice_text/TextToSpeech.h>

// VoiceText
#ifdef USE_DUMMY_INCLUDE
#include "dummy/vt_dummy.h"
#else
#include "@VT_ROOT@/inc/vtapi.h"
#endif

#include "/usr/vt/hikari/D16/inc/vtapi.h" // TODO:Delete

namespace fs = boost::filesystem;


class VoiceText {
public:
  typedef voice_text::VoiceTextConfig Config;

  VoiceText() : nh_(), pnh_("~"), db_path_(""), license_path_(""), dyn_srv_(pnh_) {
    pnh_.param<std::string>("db_path", db_path_, "@VT_ROOT@");
    pnh_.setParam("db_path", db_path_);  // for backward compatibility (db_path is usually set previously)
    pnh_.param<std::string>("license_path", license_path_, "");

    dynamic_reconfigure::Server<Config>::CallbackType f =
      boost::bind(&VoiceText::config_callback, this, _1, _2);
    dyn_srv_.setCallback(f);
  }

  ~VoiceText() {
    if (initialized_) {
      // VTAPI_UnloadEngine(-1);
      VTAPI_ReleaseHandle(this->hVTAPI);
      VTAPI_UnloadEngine(this->hEngine);
      VTAPI_Exit();
    }
  }

  void config_callback(Config &config, uint32_t level) {
    boost::mutex::scoped_lock lock(mutex_);
    config_ = config;
  }

  bool initialize() {
    // initialize voice text
    int ret = -1;
    char* db_path_char = (char*)calloc(std::strlen(db_path_.c_str())+1, sizeof(char));
    std::strcpy(db_path_char, db_path_.c_str());
    char* license_path_char = NULL;
    VTAPI_Init(NULL);
    this->hVTAPI = VTAPI_CreateHandle();
    if (ret != VTAPI_SUCCESS) {
      ROS_ERROR("VoiceText API ERROR when creating API handler. CODE: %d\n", ret);
    }
    if (!license_path_.empty()) {
      license_path_char = (char*)calloc(std::strlen(license_path_.c_str())+1, sizeof(char));
      std::strcpy(license_path_char, license_path_.c_str());
    }
    VTAPI_SetLicenseFolder(license_path_char); // set license path
    // Load engine
    this->hEngine = VTAPI_GetEngine("@VT_SPEAKER@", "@VT_TYPE@");
    ret = VTAPI_SetEngineHandle(this->hVTAPI, this->hEngine);
    if(ret != VTAPI_SUCCESS){
      ROS_ERROR("VoiceText API ERROR when creating engine handler. CODE: %d\n", ret);
    }
    // ret = VT_LOADTTS_JPN((int)NULL, -1, db_path_char, license_path_char);
    free(db_path_char);
    if (!license_path_.empty()) free(license_path_char);
    // if (ret != VTAPI_SUCCESS) {
    //   ROS_FATAL("VoiceText API ERROR when initializing. CODE: %d\n", ret);
    //   return false;
    // }

    // advertise service
    srv_ = nh_.advertiseService("text_to_speech", &VoiceText::text_to_speech, this);

    ROS_INFO_STREAM("Advertised service text_to_speech");

    return true;
  }

  bool text_to_speech(voice_text::TextToSpeech::Request  &req,
                      voice_text::TextToSpeech::Response &res) {
    boost::mutex::scoped_lock lock(mutex_);
    VTAPI_AUDIO_INFO stAudio;   // audio configuration
    int ret;
    // load text from file
    if (!fs::exists(fs::path(req.text_path))) {
      ROS_ERROR_STREAM("text file " << req.text_path << " not found");
      res.ok = false;
      return true;
    }
    std::ifstream ifs(req.text_path.c_str());
    std::string text = "", line = "";
    while (ifs && std::getline(ifs, line)) {
      text += line;
    }
    char* wave_char = (char*)calloc(std::strlen(req.wave_path.c_str())+1, sizeof(char));
    char* text_char = (char*)calloc(std::strlen(text.c_str())+1, sizeof(char));
    std::strcpy(wave_char, req.wave_path.c_str());
    std::strcpy(text_char, text.c_str());
    // set output wave file path
    ret = VTAPI_SetOutputFile(this->hVTAPI, wave_char, FORMAT_16PCM_WAV);
    if(ret != VTAPI_SUCCESS){
      ROS_ERROR("VoiceText API ERROR when executing VTAPI_SetOutputFile. STATUS: %s\n", VTAPI_GetLastErrorInfo(this->hVTAPI)->szMsg);
      res.ok = false;
    }
    // set input text file path
    ret = VTAPI_TextToFile(this->hVTAPI, text_char, -1, TEXT_FORMAT_DEFAULT);
    if(ret != VTAPI_SUCCESS){
      ROS_ERROR("VoiceText API ERROR when executing VTAPI_TextToFile. STATUS: %s\n", VTAPI_GetLastErrorInfo(this->hVTAPI)->szMsg);
      res.ok = false;
    }
    
    free(text_char);
    free(wave_char);

    res.ok = true;
    return true;
  }

  ros::NodeHandle nh_, pnh_;
  boost::mutex mutex_;
  dynamic_reconfigure::Server<Config> dyn_srv_;
  Config config_;
  ros::ServiceServer srv_;
  bool initialized_;
  std::string db_path_, license_path_;
  VTAPI_HANDLE hVTAPI;
  VTAPI_ENGINE_HANDLE hEngine;
};

int main(int argc, char** argv) {
  ros::init(argc, argv, "voice_text");

  VoiceText vt;
  if (!vt.initialize()) {
    return 1;
  };

  ros::spin();

  return 0;
}
